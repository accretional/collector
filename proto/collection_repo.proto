// collection_repo.proto
syntax = "proto3";

package collector;
option go_package = "github.com/accretional/collector/gen/collector";

import "common.proto";
import "collection.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/any.proto"; // <--- ADDED THIS IMPORT

// ============================================================================
// CollectionRepo Service
// Maintains a Collection of Collections
// Provides discovery, routing, and cross-collection search
// ============================================================================

message CreateCollectionRequest {
  Collection collection = 1;
}

message CreateCollectionResponse {
  Status status = 1;
  string collection_id = 2;
  string server_endpoint = 3;
}

message DiscoverRequest {
  string namespace = 1;  // Empty for all
  map<string, string> label_filter = 2;
  MessageTypeRef message_type_filter = 3;
  int32 page_size = 4;
  string page_token = 5;
}

message DiscoverResponse {
  Status status = 1;
  repeated Collection collections = 2;
  string next_page_token = 3;
}

message RouteRequest {
  NamespacedName collection = 1;
}

message RouteResponse {
  Status status = 1;
  string server_endpoint = 2;
  Collection collection = 3;
}

// Search across multiple collections
message SearchCollectionsRequest {
  string namespace = 1;
  repeated string collection_names = 2;
  // Empty for all
  google.protobuf.Struct query = 3;
  int32 limit = 4;
  string order_by = 5;
}

message SearchCollectionsResponse {
  message CollectionResult {
    string collection_name = 1;
    repeated google.protobuf.Any items = 2;
    map<string, double> scores = 3;
  }

  Status status = 1;
  repeated CollectionResult results = 2;
  int64 total_matches = 3;
}

// Clone a collection to another collector or location
message CloneRequest {
  NamespacedName source_collection = 1;
  string dest_namespace = 2;
  string dest_name = 3;
  string dest_endpoint = 4;  // Optional: remote collector endpoint
  bool include_files = 5;     // Include filesystem data
}

message CloneResponse {
  Status status = 1;
  string collection_id = 2;
  int64 records_cloned = 3;
  int64 files_cloned = 4;
  int64 bytes_transferred = 5;
}

// Fetch a collection from a remote collector
message FetchRequest {
  string source_endpoint = 1;  // Remote collector endpoint
  NamespacedName source_collection = 2;
  string dest_namespace = 3;   // Local namespace to create collection in
  string dest_name = 4;        // Local name for collection
  bool include_files = 5;      // Include filesystem data
}

message FetchResponse {
  Status status = 1;
  string collection_id = 2;
  int64 records_fetched = 3;
  int64 files_fetched = 4;
  int64 bytes_transferred = 5;
}

// Streaming messages for large data transfer
message PushCollectionRequest {
  // First message contains metadata
  message Metadata {
    NamespacedName source_collection = 1;
    string dest_namespace = 2;
    string dest_name = 3;
    bool include_files = 4;
    int64 total_size = 5;  // Total bytes to transfer
    MessageTypeRef message_type = 6;  // Message type of the collection
    int64 record_count = 7;  // Number of records
    int64 file_count = 8;  // Number of files
  }

  oneof data {
    Metadata metadata = 1;
    bytes chunk = 2;  // Data chunk
  }
}

message PushCollectionResponse {
  Status status = 1;
  string collection_id = 2;
  int64 records_cloned = 3;
  int64 files_cloned = 4;
  int64 bytes_received = 5;
}

message PullCollectionRequest {
  NamespacedName source_collection = 1;
  bool include_files = 2;
}

message PullCollectionChunk {
  // First message contains metadata
  message Metadata {
    string collection_id = 1;
    int64 total_size = 2;
    int64 record_count = 3;
    int64 file_count = 4;
  }

  oneof data {
    Metadata metadata = 1;
    bytes chunk = 2;  // Data chunk
  }
}

// ============================================================================
// Backup Operations
// Create point-in-time snapshots without creating collection metadata
// ============================================================================

message BackupMetadata {
  string backup_id = 1;           // Unique backup identifier
  NamespacedName collection = 2;  // Source collection
  int64 timestamp = 3;            // Unix timestamp when backup was created
  int64 size_bytes = 4;           // Total size of backup
  int64 record_count = 5;         // Number of records at backup time
  int64 file_count = 6;           // Number of files (if included)
  bool includes_files = 7;        // Whether filesystem data is included
  string storage_path = 8;        // Where backup is stored (file path or URI)
  string storage_type = 9;        // "local", "s3", "gcs", etc.
  map<string, string> metadata = 10; // Additional metadata (tags, notes)
}

message BackupCollectionRequest {
  NamespacedName collection = 1;
  string dest_path = 2;           // Local file path or URI (s3://, gcs://)
  bool include_files = 3;         // Include filesystem data
  map<string, string> metadata = 4; // Optional metadata (tags, notes, retention policy)
}

message BackupCollectionResponse {
  Status status = 1;
  BackupMetadata backup = 2;      // Metadata about the created backup
  int64 bytes_transferred = 3;
}

message ListBackupsRequest {
  NamespacedName collection = 1;  // Optional: filter by collection
  string namespace = 2;           // Optional: all backups in namespace
  int32 limit = 3;                // Max backups to return
  int64 since_timestamp = 4;      // Only backups after this time
}

message ListBackupsResponse {
  Status status = 1;
  repeated BackupMetadata backups = 2;
  int64 total_count = 3;
}

message RestoreBackupRequest {
  string backup_id = 1;           // Which backup to restore
  string dest_namespace = 2;      // Where to restore
  string dest_name = 3;           // Name of restored collection
  bool overwrite = 4;             // Allow overwriting existing collection
}

message RestoreBackupResponse {
  Status status = 1;
  string collection_id = 2;
  int64 records_restored = 3;
  int64 files_restored = 4;
}

message DeleteBackupRequest {
  string backup_id = 1;
}

message DeleteBackupResponse {
  Status status = 1;
  int64 bytes_freed = 2;
}

message VerifyBackupRequest {
  string backup_id = 1;
}

message VerifyBackupResponse {
  Status status = 1;
  bool is_valid = 2;
  string error_message = 3;       // If invalid, what's wrong
  BackupMetadata backup = 4;
}

service CollectionRepo {
  rpc CreateCollection(CreateCollectionRequest) returns (CreateCollectionResponse);
  rpc Discover(DiscoverRequest) returns (DiscoverResponse);
  rpc Route(RouteRequest) returns (RouteResponse);
  rpc SearchCollections(SearchCollectionsRequest) returns (SearchCollectionsResponse);
  rpc Clone(CloneRequest) returns (CloneResponse);
  rpc Fetch(FetchRequest) returns (FetchResponse);

  // Streaming RPCs for large data transfer
  rpc PushCollection(stream PushCollectionRequest) returns (PushCollectionResponse);
  rpc PullCollection(PullCollectionRequest) returns (stream PullCollectionChunk);

  // Backup operations - snapshots without creating collection metadata
  rpc BackupCollection(BackupCollectionRequest) returns (BackupCollectionResponse);
  rpc ListBackups(ListBackupsRequest) returns (ListBackupsResponse);
  rpc RestoreBackup(RestoreBackupRequest) returns (RestoreBackupResponse);
  rpc DeleteBackup(DeleteBackupRequest) returns (DeleteBackupResponse);
  rpc VerifyBackup(VerifyBackupRequest) returns (VerifyBackupResponse);
}
